/*
 * AUTOMATICALLY GENERATED FILE - DO NOT EDIT
 */

// Generated from /home/duck/gitclones/erpc/erpcgen/src/templates/py_coders.template
extern const char * const kPyCoders;

const char * const kPyCoders = 
"\n"
"{############################### encodeValue ###############################}\n"
"{% def encodeValue(info, name, codec, indent, depth) %}\n"
"{#--------------- struct ---------------#}\n"
"{% if info.type == \"struct\" %}\n"
"{$name}._write({$codec}){%>%}\n"
"{#--------------- union ---------------#}\n"
"{% elif info.type == \"union\" %}\n"
"{%  if info.isNonEncapsulatedUnion%}\n"
"{%   set self = \"\" %}\n"
"{% else %}\n"
"{%   set self = \"self.\" %}\n"
"{%  endif %}\n"
"codec.start_write_union({$self}{$info.discriminatorName})\n"
"{# unions are always within structs, so we have self available #}\n"
"{%  set isFirst = true %}\n"
"{%  set hasNonVoidCase = false %}\n"
"{%  set defaultCase = false %}\n"
"{%  for c in info.cases %}\n"
"{%   if c.name == \"default\" %}\n"
"{%    set defaultCase = c %}\n"
"{%   elif not c.isVoid %}\n"
"{%    set hasNonVoidCase = true %}\n"
"{$indent}{$\"if\" if isFirst else \"elif\"} {$self}{$info.discriminatorName} == {$c.value}:\n"
"{%    for cm in c.members %}\n"
"{%     if cm.isNullable %}\n"
"{$indent}    if {$name}.{$cm.name} is None:\n"
"{$indent}        {$codec}.write_null_flag(True)\n"
"{$indent}    else:\n"
"{$indent}        {$codec}.write_null_flag(False)\n"
"{$indent}    {$encodeValue(cm.type, name & \".\" & cm.name, codec, indent & \"    \", depth + 1)}\n"
"{%     else -- isNullable %}\n"
"{$indent}    if {$name}.{$cm.name} is None:\n"
"{$indent}        raise ValueError(\"{$name}.{$cm.name} is None\")\n"
"{$indent}    {$encodeValue(cm.type, name & \".\" & cm.name, codec, indent & \"    \", depth + 1)}\n"
"{%     endif -- isNullable %}\n"
"{%    endfor -- union case members %}\n"
"{%    set isFirst = false %}\n"
"{%   endif -- default case/not void %}\n"
"{%  endfor -- union cases %}\n"
"{%  if defaultCase %}\n"
"{%   if not isFirst %}\n"
"{$indent}else: # default case\n"
"{%   endif %}\n"
"{%   if defaultCase.isVoid && not isFirst %}\n"
"{$indent}    pass\n"
"{%   else %}\n"
"{%    for cm in defaultCase.members %}\n"
"{%     if cm.isNullable %}\n"
"{$indent}    if {$name}.{$cm.name} is None:\n"
"{$indent}        {$codec}.write_null_flag(True)\n"
"{$indent}    else:\n"
"{$indent}        {$codec}.write_null_flag(False)\n"
"{$indent}    {% if not isFirst %}    {% endif %}{$encodeValue(cm.type, name & \".\" & cm.name, codec, indent & \"    \", depth + 1)}\n"
"{%     else -- isNullable %}\n"
"{$indent}{% if not isFirst %}    {% endif %}{$encodeValue(cm.type, name & \".\" & cm.name, codec, indent & \"    \", depth + 1)}\n"
"{%     endif -- isNullable %}\n"
"{%    endfor -- union case members %}\n"
"{%   endif -- defaultCase.isVoid %}\n"
"{%  elif hasNonVoidCase %}\n"
"{$indent}else:\n"
"{$indent}    raise ValueError(\"invalid union discriminator value %s\" % repr({$self}{$info.discriminatorName}))\n"
"{%  endif -- defaultCase/hasNonVoidCase %}\n"
"{#--------------- enum ---------------#}\n"
"{% elif info.type == \"enum\" %}\n"
"{$codec}.write_uint32({$name}){%>%}\n"
"{#--------------- string ---------------#}\n"
"{% elif info.type == \"string\" %}\n"
"{$codec}.write_string({$name}){%>%}\n"
"{#--------------- binary ---------------#}\n"
"{% elif info.type == \"binary\" %}\n"
"{$codec}.write_binary({$name}){%>%}\n"
"{#--------------- list, array ---------------#}\n"
"{% elif info.type == \"list\" || info.type == \"array\" %}\n"
"{%  if info.type == \"list\" %}\n"
"{$codec}.start_write_list(len({$name}))\n"
"{%  endif %}\n"
"{%  if info.type == \"list\" %}{$indent}{%  endif %}for _i{$depth} in {$name}:\n"
"{$indent}    {$encodeValue(info.elementType, \"_i\" & depth, codec, indent & \"    \", depth + 1)}\n"
"{#--------------- function ---------------#}\n"
"{% elif info.type == \"function\" %}\n"
"{%  if info.tableName != \"\" %}\n"
"{$codec}.write_int8({$ info.tableName}.index({$name})){%>%}\n"
"{%  else %}\n"
"# When are defined less than 2 callback functions, eRPC don't need serialize any code.\n"
"{%  endif%}\n"
"{#--------------- else ---------------#}\n"
"{% else %}\n"
"{$codec}.write_{$info.type}({$name}){%>%}\n"
"{% endif %}\n"
"{% enddef %}\n"
"\n"
"{############################### decodeValue ###############################}\n"
"{% def decodeValue(info, name, commonPrefix, codec, indent, depth) %}\n"
"{#--------------- struct ---------------#}\n"
"{% if info.type == \"struct\" %}\n"
"{$name} = {$commonPrefix}{$info.name}()._read({$codec}){%>%}\n"
"{#--------------- union ---------------#}\n"
"{% elif info.type == \"union\" %}\n"
"{%  if info.isNonEncapsulatedUnion %}\n"
"{%   set self = \"\" %}\n"
"{%  else %}\n"
"{%   set self = \"self.\" %}\n"
"{%  endif %}\n"
"{$self}{$info.discriminatorName} = codec.start_read_union()\n"
"{%  if self == \"self.\" %}\n"
"{$indent}{$name} = {$name}_union()\n"
"{% endif %}\n"
"{%  set isFirst = true %}\n"
"{%  set hasNonVoidCase = false %}\n"
"{%  set defaultCase = false %}\n"
"{%  for c in info.cases %}\n"
"{%   if c.name == \"default\" %}\n"
"{%    set defaultCase = c %}\n"
"{%   elif not c.isVoid %}\n"
"{%    set hasNonVoidCase = true %}\n"
"{$indent}{$\"if\" if isFirst else \"elif\"} {$self}{$info.discriminatorName} == {$c.value}:\n"
"{%    for cm in c.members %}\n"
"{%     if cm.isNullable %}\n"
"{$indent}    if not {$codec}.read_null_flag()\n"
"{$indent}        {$decodeValue(cm.type, name & \".\" & cm.name, commonPrefix, codec, indent & \"    \", depth + 1)}\n"
"{$indent}    else:\n"
"{$indent}        {$name}.{$cm.name} = None\n"
"{%     else -- isNullable %}\n"
"{$indent}    {$decodeValue(cm.type, name & \".\" & cm.name, commonPrefix, codec, indent & \"    \", depth + 1)}\n"
"{%     endif -- isNullable %}\n"
"{%    endfor -- union case members %}\n"
"{%  set isFirst = false %}\n"
"{%   endif -- default/not void %}\n"
"{%  endfor -- union cases %}\n"
"{%  if defaultCase %}\n"
"{%   if not isFirst %}\n"
"{$indent}else: # default case\n"
"{%   endif %}\n"
"{%   if defaultCase.isVoid && not isFirst %}\n"
"{$indent}    pass\n"
"{%   else %}\n"
"{%    for cm in defaultCase.members %}\n"
"{%     if cm.isNullable %}\n"
"{$indent}    if not {$codec}.read_null_flag()\n"
"{$indent}    {% if not isFirst %}    {% endif %}{$decodeValue(cm.type, name & \".\" & cm.name, commonPrefix, codec, indent & \"    \", depth + 1)}\n"
"{$indent}    else:\n"
"{$indent}        {$name}.{$cm.name} = None\n"
"{%     else -- isNullable %}\n"
"{$indent}{% if not isFirst %}    {% endif %}{$decodeValue(cm.type, name & \".\" & cm.name, commonPrefix, codec, indent & \"    \", depth + 1)}\n"
"{%     endif -- isNullable %}\n"
"{%    endfor -- union case members %}\n"
"{%   endif -- defaultCase.isVoid %}\n"
"{%  elif hasNonVoidCase %}\n"
"{$indent}else:\n"
"{$indent}    raise ValueError(\"invalid union discriminator value %s\" % repr({$self}{$info.discriminatorName}))\n"
"{%  endif -- default/hasNonVoidCase %}\n"
"{#--------------- enum ---------------#}\n"
"{% elif info.type == \"enum\" %}\n"
"{$name} = {$codec}.read_uint32(){%>%}\n"
"{#--------------- string ---------------#}\n"
"{% elif info.type == \"string\" %}\n"
"{$name} = {$codec}.read_string(){%>%}\n"
"{#--------------- binary ---------------#}\n"
"{% elif info.type == \"binary\" %}\n"
"{$name} = {$codec}.read_binary(){%>%}\n"
"{#--------------- list, array ---------------#}\n"
"{% elif info.type == \"list\" || info.type == \"array\" %}\n"
"{%   if info.type == \"list\" %}\n"
"_n{$depth} = {$codec}.start_read_list()\n"
"{%   endif %}\n"
"{%   if info.type == \"list\" %}{$indent}{%   endif %}{$name} = []\n"
"{$indent}for _i{$depth} in range({% if info.type == \"list\" %}_n{$depth}{% else %}{$info.elementCount}{% endif %}):\n"
"{$indent}    {$decodeValue(info.elementType, \"_v\" & depth, commonPrefix, codec, indent & \"    \", depth + 1)}\n"
"{$indent}    {$name}.append(_v{$depth})\n"
"{#--------------- function ---------------#}\n"
"{% elif info.type == \"function\" %}\n"
"{%  if info.tableName != \"\" %}\n"
"{$name} = {$ info.tableName}[{$codec}.read_int8()]\n"
"{%  else %}\n"
"# When are defined less than 2 callback functions, eRPC don't need serialize any code.\n"
"{$indent}{$name} = {$info.callbackName}\n"
"{%  endif%}\n"
"{#--------------- else ---------------#}\n"
"{% else %}\n"
"{$name} = {$codec}.read_{$info.type}(){%>%}\n"
"{% endif %}\n"
"{% enddef %}\n"
"\n"
"{############################### prettyTypeName ###############################}\n"
"{% def prettyTypeName(name, info) %}\n"
"{% if info.type == \"list\" %}\n"
"list<{$prettyTypeName(\"\", info.elementType)}>{%>%}\n"
"{% elif info.type == \"array\" %}\n"
"{$prettyTypeName(\"\", info.elementType)}[{$info.elementCount}]\n"
"{% elif info.type == \"union\" %}\n"
"{%  if info.isNonEncapsulatedUnion == true %}\n"
"{$info.name}{%>%}\n"
"{%  else %}\n"
"{$name}_union{%>%}\n"
"{% endif %}\n"
"{% else %}\n"
"{$info.name}{%>%}\n"
"{% endif %}\n"
"{% enddef %}\n"
;

