/*
 * AUTOMATICALLY GENERATED FILE - DO NOT EDIT
 */

// Generated from /home/duck/gitclones/erpc/erpcgen/src/templates/py_common.template
extern const char * const kPyCommon;

const char * const kPyCommon = 
"{% if mlComment != \"\"%}\n"
"{$mlComment}\n"
"\n"
"{% endif %}\n"
"#\n"
"# Generated by erpcgen {$erpcVersion} on {$todaysDate}.\n"
"#\n"
"# AUTOGENERATED - DO NOT EDIT\n"
"#\n"
"\n"
"import erpc\n"
"{% for inc in includes %}\n"
"import {$inc}\n"
"{% endfor -- includes %}\n"
"{% if not empty(consts) %}\n"
"\n"
"# Constant variable declarations\n"
"{% for c in consts %}\n"
"{$>c.mlComment}\n"
"{$c.name} = {$c.value}{% if c.ilComment %} {$c.ilComment}{% endif %}\n"
"{% endfor -- constants %}\n"
"{% endif -- consts %}\n"
"{% if not empty(enums) %}\n"
"\n"
"# Enumerators data types declarations\n"
"{% for enum in enums %}\n"
"{$>(enum.mlComment or enum.ilComment)}\n"
"{% if enum.name %}\n"
"class {$enum.name}:\n"
"{% endif -- anon enum %}\n"
"{% for member in enum.members %}\n"
"{% if member.mlComment %}\n"
"   {$member.mlComment}\n"
"{% endif %}\n"
"{% if enum.name %}    {% endif %}{$member.name} = {$member.value}{% if member.ilComment %} {$member.ilComment}{% endif %}\n"
"{% endfor -- member %}\n"
"\n"
"{% endfor -- enum %}\n"
"{% endif -- enums %}\n"
"\n"
"{% if not empty(group.symbolsMap.structs) %}\n"
"# Structures data types declarations\n"
"{% for s in group.symbolsMap.structs %}\n"
"{$>(s.mlComment or s.ilComment)}\n"
"class {$s.name}(object):\n"
"{% for m in s.members if (m.type.type == 'union' && m.type.isNonEncapsulatedUnion == false) %}\n"
"{%   if m.mlComment or m.ilComment %}\n"
"   {$m.mlComment or m.ilComment}\n"
"{%   endif %}\n"
"    class {$m.name}_union(object):\n"
"{%   for c in m.type.cases %}\n"
"{%    if not c.isVoid %}\n"
"        # {% if c.name == \"default\" %}default case{% else %}case {$c.name or c.value}{% endif %}\n"
"{%     for cm in c.members %}\n"
"        {$cm.name} = None # {$prettyTypeName(cm.name, cm.type)}\n"
"{%     endfor -- union case members %}\n"
"{%    endif -- not void %}\n"
"{%   endfor -- union cases %}\n"
"\n"
"{% endfor -- members %}\n"
"    def __init__(self{% for m in s.members if ((not m.lengthForMember) && m.type.type != 'union') %}, {$m.name}=None{% endfor %}):\n"
"{% for m in s.members if not m.lengthForMember %}\n"
"{%     if (m.type.type == 'union' && m.type.isNonEncapsulatedUnion == false) %}\n"
"        self.{$m.name} = self.{$m.name}_union # {$prettyTypeName(m.name, m.type)}\n"
"{%     else %}\n"
"        self.{$m.name} = {$m.name} # {$prettyTypeName(m.name, m.type)}\n"
"{%     endif -- union type %}\n"
"{% endfor -- members %}\n"
"\n"
"{# create read-only properties for @length counts #}\n"
"{% for m in s.members if m.lengthForMember %}\n"
"    @property\n"
"    def {$m.name}(self):\n"
"        return len(self.{$m.lengthForMember})\n"
"\n"
"{% endfor -- s.members %}\n"
"    def _read(self, codec):\n"
"{% for m in s.members if not m.serializedViaMember %}\n"
"{%   set self_m_name = \"self.\" & m.name %}\n"
"{%   if m.isNullable %}\n"
"        if not codec.read_null_flag():\n"
"            {$decodeValue(m.type, self_m_name, \"\", \"codec\", \"            \", 0)}\n"
"        else:\n"
"            {$self_m_name} = None\n"
"{%   else -- isNullable %}\n"
"{%    if (m.type.type == 'union' && m.type.isNonEncapsulatedUnion == true) %}\n"
"        {$self_m_name}, self.{$m.discriminator} = common.{$m.type.name}()._read(codec)\n"
"{%    else -- isNonEncapsulatedUnion %}\n"
"        {$decodeValue(m.type, self_m_name, \"\", \"codec\", \"        \", 0)}\n"
"{%    endif -- isNonEncapsulatedUnion %}\n"
"{%   endif -- isNullable %}\n"
"{% endfor -- members %}\n"
"        return self\n"
"\n"
"    def _write(self, codec):\n"
"{% for m in s.members if not m.serializedViaMember %}\n"
"{%  set self_m_name = \"self.\" & m.name %}\n"
"{%  if m.isNullable %}\n"
"        if {$self_m_name} is None:\n"
"            codec.write_null_flag(True)\n"
"        else:\n"
"            codec.write_null_flag(False)\n"
"            {$encodeValue(m.type, self_m_name, \"codec\", \"            \", 0)}\n"
"{%  else -- isNullable %}\n"
"        if {$self_m_name} is None:\n"
"            raise ValueError(\"{$m.name} is None\")\n"
"{%    if (m.type.type == 'union' && m.type.isNonEncapsulatedUnion == true) %}\n"
"        self.{$m.name}._write(codec, self.{$m.discriminator})\n"
"{%    else -- isNonEncapsulatedUnion %}\n"
"        {$encodeValue(m.type, self_m_name, \"codec\", \"        \", 0)}\n"
"{%    endif -- isNonEncapsulatedUnion %}\n"
"{%  endif -- isNullable %}\n"
"{% endfor -- members %}\n"
"\n"
"    def __str__(self):\n"
"        return \"<%s@%x{% for m in s.members if not m.lengthForMember %} {$m.name}=%s{% endfor %}>\" % (self.__class__.__name__, id(self){% for m in s.members if not m.lengthForMember %}, self.{$m.name}{% endfor %})\n"
"\n"
"    def __repr__(self):\n"
"        return self.__str__()\n"
"        \n"
"{% endfor -- group.symbolsMap.structs %}\n"
"{% endif -- not empty(group.symbolsMap.structs) %}\n"
"{% if not empty(group.symbolsMap.unions) %}\n"
"\n"
"# Unions data types declarations\n"
"{% for u in group.symbolsMap.unions %}\n"
"{$>(u.mlComment or u.ilComment)}\n"
"class {$u.name}(object):\n"
"{%  for c in u.type.cases %}\n"
"{%   if not c.isVoid %}\n"
"    # {% if c.name == \"default\" %}default case{% else %}case {$c.name or c.value}{% endif %}\n"
"{%    for cm in c.members %}\n"
"    {$cm.name} = None # {$prettyTypeName(cm.name, cm.type)}\n"
"{%    endfor -- union case members %}\n"
"{%   endif -- not void %}\n"
"{%  endfor -- union cases %}\n"
"\n"
"    def _read(self, codec):\n"
"        {$decodeValue(u.type, \"self\", \"\", \"codec\", \"        \", 0)}\n"
"        return self, discriminator\n"
"\n"
"    def _write(self, codec, discriminator):\n"
"        {$encodeValue(u.type, \"self\", \"codec\", \"        \", 0)}\n"
"\n"
"{#    def __str__(self):\n"
"        return \"<%s@%x{% for m in u.members if not m.lengthForMember %} {$m.name}=%s{% endfor %}>\" % (self.__class__.__name__, id(self){% for m in u.members if not m.lengthForMember %}, self.{$m.name}{% endfor %})\n"
"#}\n"
"    def __repr__(self):\n"
"        return self.__str__()\n"
"\n"
"{% endfor -- group.symbolsMap.unions %}\n"
"{% endif -- not empty(group.symbolsMap.unions) %}\n"
"{% if not empty(group.symbolsMap.aliases) %}\n"
"\n"
"# Type aliases\n"
"{% for a in group.symbolsMap.aliases %}\n"
"{$a.name} = {$a.elementType.name}\n"
"{% endfor -- group.symbolsMap.aliases %}\n"
"{% endif -- not empty(group.symbolsMap.aliases) %}"
;

